---
phase: 05-private-transfer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/railgun-clean/operations/transfer.js
  - frontend/src/lib/railgun-clean/index.js
autonomous: true

must_haves:
  truths:
    - "privateTransfer function executes 3-step SDK flow (estimate, prove, populate)"
    - "Function returns memoHash and railgunTxRef (nullifiers[0]) for on-chain recording"
    - "Progress callback reports proof generation status"
  artifacts:
    - path: "frontend/src/lib/railgun-clean/operations/transfer.js"
      provides: "Private transfer implementation using SDK"
      exports: ["privateTransfer"]
    - path: "frontend/src/lib/railgun-clean/index.js"
      provides: "Re-exports privateTransfer from operations/transfer.js"
      contains: "export.*privateTransfer.*from.*operations/transfer"
  key_links:
    - from: "frontend/src/lib/railgun-clean/operations/transfer.js"
      to: "@railgun-community/wallet"
      via: "SDK function calls"
      pattern: "gasEstimateForUnprovenTransfer|generateTransferProof|populateProvedTransfer"
---

<objective>
Create the core private transfer function using Railgun SDK's 3-step flow.

Purpose: Enable private payments between buyer and seller Railgun addresses (0zk -> 0zk)
Output: `transfer.js` module with `privateTransfer` function exported from index.js
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-private-transfer/05-RESEARCH.md
@.planning/phases/04-weth-shielding/04-01-SUMMARY.md
@frontend/src/lib/railgun-clean/shield.js
@frontend/src/lib/railgun-client-browser.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transfer.js with 3-step SDK flow</name>
  <files>frontend/src/lib/railgun-clean/operations/transfer.js</files>
  <action>
Create `operations/transfer.js` following the pattern from shield.js.

**Imports:**
```javascript
import { ethers } from 'ethers';
import {
  NetworkName,
  NETWORK_CONFIG,
  TXIDVersion,
  EVMGasType,
  getEVMGasTypeForTransaction,
} from '@railgun-community/shared-models';
import {
  gasEstimateForUnprovenTransfer,
  generateTransferProof,
  populateProvedTransfer,
  refreshBalances,
} from '@railgun-community/wallet';
import { initializeSDK } from '../railgun-client-browser';
```

**Function signature:**
```javascript
export async function privateTransfer({
  toRailgunAddress,    // Recipient 0zk address
  amountWei,           // BigInt amount
  tokenAddress,        // ERC-20 address (default: WETH)
  productId,           // For memo generation
  onProgress           // Progress callback: (state) => void
})
```

**Implementation flow:**
1. Validate inputs (toRailgunAddress starts with '0zk', amountWei > 0)
2. Ensure SDK initialized via `initializeSDK()`
3. Get wallet info from localStorage (`railgun.wallet`)
4. Extract `walletID` from stored data

**CRITICAL: Derive encryptionKey from signature (NOT stored in localStorage)**
The encryptionKey is NOT stored. Derive it like shield.js derives shieldPrivateKey:
```javascript
// Get signer from MetaMask
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();
const fromWalletAddress = await signer.getAddress();

// Derive encryptionKey from signature (same pattern as shield.js getShieldPrivateKey)
const baseMsg = 'Railgun Wallet Encryption Key'; // Fixed message
const contextualMsg = `${baseMsg}\nChain: ${NetworkName.EthereumSepolia}\nEOA: ${fromWalletAddress}`;
const sig = await signer.signMessage(contextualMsg);
const encryptionKey = ethers.keccak256(ethers.toUtf8Bytes(sig));
```

5. Setup network: `NetworkName.EthereumSepolia`, get chain from NETWORK_CONFIG
6. Use WETH if tokenAddress not provided: `sepoliaConfig.baseToken.wrappedAddress`
7. Build `erc20AmountRecipients` array with BigInt amount (NOT string like shield)
8. Generate memoText: `EV-Battery-Payment:${productId}:${Date.now()}`
9. Compute memoHash: `ethers.keccak256(ethers.toUtf8Bytes(memoText))`
10. Get gas details (Type2 with maxFeePerGas, maxPriorityFeePerGas)
11. Call `gasEstimateForUnprovenTransfer` - use TXIDVersion.V2_PoseidonMerkle, networkName string
12. Call `generateTransferProof` with progress callback
13. Call `populateProvedTransfer` - extracts nullifiers
14. Extract `railgunTxRef = nullifiers[0]`
15. Send transaction via signer.sendTransaction
16. Wait for confirmation
17. Refresh balances (non-blocking, same pattern as shield.js)
18. Return `{ success: true, txHash, memoHash, railgunTxRef, nullifiers }`

**Key differences from shield.js:**
- Use BigInt for amount (not string)
- Requires encryptionKey derived from signature
- 3 SDK calls instead of 2
- Returns memoHash and railgunTxRef for Phase 6

**Error handling:**
- Wrap each SDK call in try-catch
- Report failures with onProgress({ step: 'error', message })
- Return { success: false, error } on failure
  </action>
  <verify>grep -q 'export async function privateTransfer' frontend/src/lib/railgun-clean/operations/transfer.js && echo "Function exported correctly"</verify>
  <done>transfer.js created with privateTransfer function implementing 3-step SDK flow with signature-derived encryptionKey</done>
</task>

<task type="auto">
  <name>Task 2: Export privateTransfer from index.js</name>
  <files>frontend/src/lib/railgun-clean/index.js</files>
  <action>
Update index.js to export the new privateTransfer function.

1. Add import at top (near other imports):
```javascript
import { privateTransfer as sdkPrivateTransfer } from './operations/transfer';
```

2. Update the existing `privateTransfer` alias to use the real implementation:
```javascript
// Replace the existing alias line:
// export const privateTransfer = paySellerV2;
// With:
export const privateTransfer = sdkPrivateTransfer;
```

3. Also export `paySellerV2` as an alias for backward compatibility (it should call privateTransfer internally now)

4. Add to default export object:
```javascript
privateTransfer: sdkPrivateTransfer,
```

Note: The existing `paySellerV2` in payments.js will be updated in the next plan to use the new function.
  </action>
  <verify>grep -n "privateTransfer" frontend/src/lib/railgun-clean/index.js | grep -q "operations/transfer" && echo "Import added correctly"</verify>
  <done>index.js updated with privateTransfer export from operations/transfer.js</done>
</task>

</tasks>

<verification>
1. `frontend/src/lib/railgun-clean/operations/transfer.js` exists and exports `privateTransfer`
2. `frontend/src/lib/railgun-clean/index.js` re-exports `privateTransfer`
3. Function signature matches research document
4. SDK imports are correct (gasEstimateForUnprovenTransfer, generateTransferProof, populateProvedTransfer)
5. encryptionKey is derived from signature (NOT read from localStorage)
6. memoHash and railgunTxRef are returned for Phase 6 on-chain recording
</verification>

<success_criteria>
- [ ] transfer.js created in operations/ directory
- [ ] privateTransfer function implements 3-step SDK flow
- [ ] encryptionKey derived from MetaMask signature (like shield.js pattern)
- [ ] Uses TXIDVersion.V2_PoseidonMerkle (not string)
- [ ] Uses BigInt for amounts (not string)
- [ ] Returns { success, txHash, memoHash, railgunTxRef, nullifiers }
- [ ] Progress callback invoked during proof generation
- [ ] index.js exports privateTransfer
</success_criteria>

<output>
After completion, create `.planning/phases/05-private-transfer/05-01-SUMMARY.md`
</output>
