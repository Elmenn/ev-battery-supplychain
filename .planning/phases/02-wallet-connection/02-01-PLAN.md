---
phase: 02-wallet-connection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/lib/railgun-clean/crypto.js
  - frontend/src/lib/railgun-clean/connection.js
  - frontend/src/lib/railgun-client-browser.js
autonomous: true

must_haves:
  truths:
    - "Mnemonic is encrypted before storage"
    - "Same MetaMask signature always produces same encryption key"
    - "Wallet connection persists across page refresh"
    - "Different MetaMask account gets different Railgun wallet"
  artifacts:
    - path: "frontend/src/lib/railgun-clean/crypto.js"
      provides: "AES-GCM encryption/decryption utilities"
      exports: ["encryptMnemonic", "decryptMnemonic", "deriveKeyFromSignature"]
    - path: "frontend/src/lib/railgun-clean/connection.js"
      provides: "Connection flow with encrypted mnemonic storage"
      contains: "FIXED_SIGNING_MESSAGE"
  key_links:
    - from: "connection.js"
      to: "crypto.js"
      via: "import encryptMnemonic, decryptMnemonic"
      pattern: "import.*from.*crypto"
    - from: "connection.js"
      to: "localStorage"
      via: "setItem with encrypted payload"
      pattern: "localStorage\\.setItem.*encryptedMnemonic"
---

<objective>
Implement secure encrypted mnemonic storage for Railgun wallet connection.

Purpose: The current implementation creates a new wallet on every connection because the signing message includes a timestamp, making it non-deterministic. The mnemonic is generated but never stored, so connection cannot be restored. This plan fixes both issues by using a fixed signing message and storing the mnemonic encrypted with AES-GCM.

Output: Working connection flow where wallet persists across sessions via encrypted mnemonic storage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-wallet-connection/02-RESEARCH.md

# Source files to modify
@frontend/src/lib/railgun-clean/connection.js
@frontend/src/lib/railgun-client-browser.js
@frontend/src/lib/railgun-clean/index.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create crypto.js with AES-GCM encryption utilities</name>
  <files>frontend/src/lib/railgun-clean/crypto.js</files>
  <action>
Create new file `crypto.js` in railgun-clean directory with Web Crypto API-based encryption:

1. `deriveKeyFromSignature(signature)` - Derive AES-256 key from signature using PBKDF2:
   - Use fixed salt stored in localStorage (or generate on first use)
   - 100,000 iterations for brute-force resistance
   - Return CryptoKey object for use with encrypt/decrypt

2. `encryptMnemonic(mnemonic, signature)` - Encrypt mnemonic:
   - Generate random 12-byte IV
   - Derive key from signature
   - Encrypt using AES-GCM
   - Return object: `{ iv: number[], salt: number[], data: number[] }`

3. `decryptMnemonic(encryptedPayload, signature)` - Decrypt mnemonic:
   - Extract iv, salt, data from payload
   - Derive key from signature (using stored salt)
   - Decrypt using AES-GCM
   - Return plaintext mnemonic string

Handle errors gracefully - return null on decryption failure (key mismatch).

Reference Research pattern:
```javascript
const keyMaterial = await crypto.subtle.importKey(
  "raw",
  encoder.encode(signature),
  "PBKDF2",
  false,
  ["deriveKey"]
);
const key = await crypto.subtle.deriveKey(
  { name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256" },
  keyMaterial,
  { name: "AES-GCM", length: 256 },
  false,
  ["encrypt", "decrypt"]
);
```
  </action>
  <verify>
File exists at frontend/src/lib/railgun-clean/crypto.js with three exported functions.
Run: `node -e "import('./frontend/src/lib/railgun-clean/crypto.js').then(m => console.log(Object.keys(m)))"` should show exports.
  </verify>
  <done>crypto.js exports encryptMnemonic, decryptMnemonic, deriveKeyFromSignature</done>
</task>

<task type="auto">
  <name>Task 2: Update connection.js to use fixed signing message and encrypted storage</name>
  <files>frontend/src/lib/railgun-clean/connection.js</files>
  <action>
Modify connection.js to implement secure, persistent wallet connection:

1. Add import at top:
   ```javascript
   import { encryptMnemonic, decryptMnemonic } from './crypto.js';
   ```

2. Define fixed signing message constant (NO timestamp):
   ```javascript
   const FIXED_SIGNING_MESSAGE = "Railgun Wallet Encryption Key";
   ```

3. Modify `connectRailgun()` function:

   a. Change signature request to use fixed message:
   ```javascript
   const msg = FIXED_SIGNING_MESSAGE;
   const signature = await signer.signMessage(msg);
   ```

   b. Check for existing encrypted mnemonic FIRST:
   ```javascript
   const stored = JSON.parse(localStorage.getItem('railgun.wallet') || 'null');
   if (stored && stored.encryptedMnemonic && stored.userAddress?.toLowerCase() === eoaAddress.toLowerCase()) {
     // Decrypt and reload existing wallet
     const mnemonic = await decryptMnemonic(stored.encryptedMnemonic, signature);
     if (mnemonic) {
       // Use existing mnemonic to recreate wallet
       const walletInfo = await client.createWalletFromSignature(signature, {
         userAddress: eoaAddress,
         mnemonic // Pass existing mnemonic
       });
       // ... rest of success flow
     }
   }
   ```

   c. For NEW wallet creation, encrypt mnemonic BEFORE storing:
   ```javascript
   const walletInfo = await client.createWalletFromSignature(signature, { userAddress: eoaAddress });
   const encryptedMnemonic = await encryptMnemonic(walletInfo.mnemonic, signature);

   const store = {
     walletID: walletInfo.walletID,
     railgunAddress: walletInfo.railgunAddress,
     userAddress: eoaAddress.toLowerCase(),
     encryptedMnemonic,
     timestamp: Date.now()
   };
   localStorage.setItem('railgun.wallet', JSON.stringify(store));
   ```

4. Modify `restoreRailgunConnection()`:
   - Must request signature (fixed message) to decrypt mnemonic
   - Use decrypted mnemonic to reload wallet
   - If decryption fails, treat as no stored connection

Key constraints:
- NEVER store plaintext mnemonic
- Fixed message ensures same signature for same EOA
- Mnemonic encrypted per-user (different EOAs get different encryption)
  </action>
  <verify>
1. `grep "FIXED_SIGNING_MESSAGE" frontend/src/lib/railgun-clean/connection.js` shows the constant
2. `grep "encryptMnemonic" frontend/src/lib/railgun-clean/connection.js` shows import and usage
3. `grep "decryptMnemonic" frontend/src/lib/railgun-clean/connection.js` shows import and usage
  </verify>
  <done>connection.js uses fixed signing message and stores encrypted mnemonic</done>
</task>

<task type="auto">
  <name>Task 3: Update railgun-client-browser.js to accept mnemonic parameter</name>
  <files>frontend/src/lib/railgun-client-browser.js</files>
  <action>
Modify `createWalletFromSignature()` to accept optional mnemonic for wallet recreation:

1. Update function signature:
   ```javascript
   export async function createWalletFromSignature(signature, opts = {}) {
     // opts can now include: { userAddress, mnemonic }
   ```

2. Check for provided mnemonic before generating:
   ```javascript
   // Use provided mnemonic (for restore) or generate new one
   const mnemonic = opts.mnemonic || (Wallet.createRandom().mnemonic || {}).phrase || null;

   if (!mnemonic) {
     throw new Error('Failed to get or generate mnemonic');
   }
   ```

3. Return mnemonic in response (needed for initial encryption):
   ```javascript
   return { walletID, railgunAddress, encryptionKey, mnemonic };
   ```

This change is backward-compatible: existing calls without mnemonic continue to generate new ones.
  </action>
  <verify>
1. `grep "opts.mnemonic" frontend/src/lib/railgun-client-browser.js` shows the check
2. Read file and verify mnemonic is returned in the response object
  </verify>
  <done>createWalletFromSignature accepts optional mnemonic for wallet restoration</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Encryption utilities exist:**
   - `ls frontend/src/lib/railgun-clean/crypto.js` shows file
   - File exports encryptMnemonic, decryptMnemonic

2. **Connection uses fixed message:**
   - `grep -n "FIXED_SIGNING_MESSAGE" frontend/src/lib/railgun-clean/connection.js`
   - No timestamp in signing message

3. **Encrypted storage in place:**
   - `grep "encryptedMnemonic" frontend/src/lib/railgun-clean/connection.js`
   - Shows both encrypt (store) and decrypt (restore) usage

4. **No plaintext mnemonic storage:**
   - `grep -n "mnemonic" frontend/src/lib/railgun-clean/connection.js | grep -v encrypt | grep -v decrypt`
   - Should NOT show any localStorage.setItem with raw mnemonic
</verification>

<success_criteria>
- crypto.js created with AES-GCM utilities
- connection.js uses FIXED_SIGNING_MESSAGE (no timestamp)
- Mnemonic encrypted before localStorage storage
- createWalletFromSignature accepts mnemonic parameter for restore
- Same EOA + signature always produces same encryption key
</success_criteria>

<output>
After completion, create `.planning/phases/02-wallet-connection/02-01-SUMMARY.md`
</output>
