---
phase: 07-smart-contract-redesign
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - test/EscrowTimeouts.test.js
  - migrations/2_deploy_redesigned.js
autonomous: true

must_haves:
  truths:
    - "sellerTimeout slashes seller bond to buyer after 2-day window"
    - "bidTimeout returns seller bond to seller and allows transporter withdrawals"
    - "deliveryTimeout slashes transporter bond to seller and returns seller bond + fee"
    - "Timeouts revert if called before window expires"
    - "Timeouts revert if called in wrong phase"
    - "Migration deploys new implementation and factory with bond amount"
  artifacts:
    - path: "test/EscrowTimeouts.test.js"
      provides: "Timeout/slash logic tests for all three timeout paths"
      min_lines: 150
    - path: "migrations/2_deploy_redesigned.js"
      provides: "Truffle migration for new contracts with bond configuration"
      min_lines: 15
  key_links:
    - from: "test/EscrowTimeouts.test.js"
      to: "contracts/ProductEscrow_Initializer.sol"
      via: "sellerTimeout, bidTimeout, deliveryTimeout function calls"
      pattern: "(sellerTimeout|bidTimeout|deliveryTimeout)"
---

<objective>
Write timeout/slash tests covering all three timeout paths with correct bond distribution, and create a deployment migration script for the redesigned contracts.

Purpose: Timeout logic is the most complex part of the escrow and the area where the original contract had a double-payment bug. Thorough testing is critical. The migration script enables Sepolia deployment.
Output: Timeout test file and Truffle migration script.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-smart-contract-redesign/07-CONTEXT.md
@.planning/phases/07-smart-contract-redesign/07-RESEARCH.md
@.planning/phases/07-smart-contract-redesign/07-01-SUMMARY.md
@contracts/ProductEscrow_Initializer.sol
@contracts/ProductFactory.sol
@migrations/1_initial_migration.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Timeout and slash logic tests</name>
  <files>test/EscrowTimeouts.test.js</files>
  <action>
  Create test/EscrowTimeouts.test.js following the existing Truffle test pattern. Use accounts: [deployer, seller, buyer, transporter, anyone].

  **Time manipulation:** Use `evm_increaseTime` and `evm_mine` to advance blockchain time past timeout windows:
  ```javascript
  const advanceTime = async (seconds) => {
    await web3.currentProvider.send({ jsonrpc: "2.0", method: "evm_increaseTime", params: [seconds], id: 0 }, () => {});
    await web3.currentProvider.send({ jsonrpc: "2.0", method: "evm_mine", params: [], id: 0 }, () => {});
  };
  const TWO_DAYS = 2 * 24 * 60 * 60; // 172800 seconds
  ```

  **Test helper (beforeEach):**
  - Deploy implementation + factory, setBondAmount(0.01 ETH)
  - Create product with seller bond
  - Store bondAmount, commitment for reuse

  **Test categories:**

  1. **sellerTimeout (Phase: Purchased -> Expired):**
     - Setup: recordPrivatePayment to move to Purchased
     - Advance time by TWO_DAYS + 1
     - Anyone calls sellerTimeout()
     - Verify: seller bond slashed to buyer (buyer balance increases by bondAmount, minus gas if buyer calls)
     - Verify: phase == Expired
     - Verify: sellerBond == 0 in contract
     - Verify: contract balance == 0
     - Event: BondSlashed emitted with seller -> buyer
     - Revert: sellerTimeout before window expires
     - Revert: sellerTimeout in wrong phase (Listed, OrderConfirmed, Bound, Delivered)

  2. **bidTimeout (Phase: OrderConfirmed -> Expired):**
     - Setup: recordPrivatePayment + confirmOrder to reach OrderConfirmed
     - Have 2 transporters bid (both stake bonds)
     - Advance time by TWO_DAYS + 1
     - Anyone calls bidTimeout()
     - Verify: seller bond returned to seller
     - Verify: phase == Expired
     - Verify: transporter bonds NOT automatically returned (they use withdrawBid)
     - After bidTimeout: transporter1 calls withdrawBid() -> receives bond back
     - After bidTimeout: transporter2 calls withdrawBid() -> receives bond back
     - Verify: contract balance == 0 after all withdrawals
     - Event: BondReturned emitted for seller
     - Revert: bidTimeout before window expires
     - Revert: bidTimeout in wrong phase

  3. **deliveryTimeout (Phase: Bound -> Expired):**
     - Setup: full flow to Bound (recordPrivatePayment + confirmOrder + createTransporter + setTransporter)
     - Advance time by TWO_DAYS + 1
     - Anyone calls deliveryTimeout()
     - Verify: seller bond returned to seller
     - Verify: transporter bond slashed to seller (seller gets sellerBond + transporterBond + deliveryFee)
     - Verify: phase == Expired
     - Verify: contract balance == 0
     - Events: BondReturned for seller bond, BondSlashed for transporter bond
     - Revert: deliveryTimeout before window expires
     - Revert: deliveryTimeout in wrong phase

  4. **Timeout edge cases:**
     - Cannot call any timeout after successful delivery (phase == Delivered)
     - Cannot call timeout twice on same product (phase already Expired)
     - Timeout is permissionless (anyone account can trigger all three)
     - Exact boundary: timeout at exactly TWO_DAYS should revert, at TWO_DAYS + 1 should succeed

  5. **Double-payment bug regression:**
     - In the old contract, _timeout() sent productPrice + penalty to buyer, then penalty again
     - Verify that in the new contract, each timeout sends the correct total amount exactly once
     - After any timeout, contract balance must be exactly 0 (no stuck funds, no over-send)

  **Balance verification pattern:**
  ```javascript
  const balBefore = BigInt(await web3.eth.getBalance(recipient));
  const tx = await escrow.sellerTimeout({ from: anyone });
  const balAfter = BigInt(await web3.eth.getBalance(recipient));
  // If recipient != anyone (caller), no gas cost to account for
  assert.equal(balAfter - balBefore, BigInt(bondAmount));
  ```
  Use a non-recipient account (anyone) to call timeouts so balance checks are clean (no gas deduction).
  </action>
  <verify>Run `npx truffle test test/EscrowTimeouts.test.js --network development`. All tests pass.</verify>
  <done>All three timeout paths tested with correct bond distribution. Time manipulation confirms windows are enforced. Double-payment regression test passes. Contract balance is 0 after every timeout scenario.</done>
</task>

<task type="auto">
  <name>Task 2: Create deployment migration script</name>
  <files>migrations/2_deploy_redesigned.js</files>
  <action>
  Create migrations/2_deploy_redesigned.js for deploying the redesigned contracts. Follow the pattern from 1_initial_migration.js.

  **Migration steps:**
  1. Deploy new ProductEscrow_Initializer (implementation contract)
  2. Deploy new ProductFactory with implementation address
  3. Call factory.setBondAmount(web3.utils.toWei("0.01", "ether")) to set default bond for Sepolia
  4. Log all addresses

  ```javascript
  const ProductEscrow_Initializer = artifacts.require("ProductEscrow_Initializer");
  const ProductFactory = artifacts.require("ProductFactory");

  module.exports = async function (deployer) {
    console.log("Deploying redesigned contracts...");

    // Deploy new implementation
    await deployer.deploy(ProductEscrow_Initializer);
    const implementation = await ProductEscrow_Initializer.deployed();
    console.log("Implementation:", implementation.address);

    // Deploy new factory
    await deployer.deploy(ProductFactory, implementation.address);
    const factory = await ProductFactory.deployed();
    console.log("Factory:", factory.address);

    // Set default bond amount (0.01 ETH for Sepolia testnet)
    const bondAmount = web3.utils.toWei("0.01", "ether");
    await factory.setBondAmount(bondAmount);
    console.log("Bond amount set to:", bondAmount, "wei (0.01 ETH)");

    console.log("Deployment complete!");
    console.log("Implementation:", implementation.address);
    console.log("Factory:", factory.address);
  };
  ```

  **Note:** This is migration #2, which deploys fresh contracts (clean break from old contracts as recommended in research). The old migration (#1) still exists for reference but the new contracts supersede the old ones.
  </action>
  <verify>Run `npx truffle migrate --reset --network development` to verify migration runs successfully on local Ganache. Check that factory.bondAmount() returns 0.01 ETH.</verify>
  <done>Migration script deploys new implementation and factory, sets bond amount to 0.01 ETH. Migration runs successfully on Ganache.</done>
</task>

</tasks>

<verification>
1. `npx truffle test test/EscrowTimeouts.test.js` — all tests pass
2. `npx truffle migrate --reset --network development` — migration completes
3. sellerTimeout correctly slashes seller bond to buyer
4. bidTimeout returns seller bond, allows transporter withdrawals
5. deliveryTimeout slashes transporter bond + returns seller bond + fee to seller
6. No double-payment: contract balance is 0 after every timeout
7. Factory bondAmount is set to 0.01 ETH after migration
</verification>

<success_criteria>
All timeout tests pass with correct bond distribution verified by balance checks. Migration script deploys successfully and configures bond amount. The double-payment bug from the old contract is confirmed fixed by regression test.
</success_criteria>

<output>
After completion, create `.planning/phases/07-smart-contract-redesign/07-03-SUMMARY.md`
</output>
