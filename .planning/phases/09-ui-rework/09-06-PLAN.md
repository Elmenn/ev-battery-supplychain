---
phase: 09-ui-rework
plan: 06
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - frontend/src/components/railgun/PrivatePaymentModal.jsx
autonomous: true

must_haves:
  truths:
    - "PrivatePaymentModal is a stepped drawer: connect -> balance check -> pay"
    - "If already connected and funded, fast-path jumps directly to pay step"
    - "Buyer enters/confirms payment amount (not shown on public listing)"
    - "Balance check shows immediate sufficient/insufficient indicator"
    - "After payment, recordPrivatePayment is called on-chain automatically"
    - "Dead code removed: mock wallet managers, shield step, connection polling, backend API calls"
  artifacts:
    - path: "frontend/src/components/railgun/PrivatePaymentModal.jsx"
      provides: "Stepped private payment drawer for buyers"
      min_lines: 200
  key_links:
    - from: "frontend/src/components/railgun/PrivatePaymentModal.jsx"
      to: "frontend/src/lib/railgun-clean/index.js"
      via: "barrel import for privateTransfer, getAllBalances, checkWalletState, refreshBalances, connectRailgun"
      pattern: "from '../../lib/railgun-clean'"
    - from: "frontend/src/components/railgun/PrivatePaymentModal.jsx"
      to: "frontend/src/utils/escrowHelpers.js"
      via: "getEscrowContract for recordPrivatePayment"
      pattern: "import.*escrowHelpers"
---

<objective>
Rewrite PrivatePaymentModal.jsx as a stepped drawer with connect/balance/pay flow, removing ~70% dead code and adding the FCFS buyer recordPrivatePayment call.

Purpose: The current PrivatePaymentModal is 1632 lines with massive dead code from mock wallet managers, backend API integration, and obsolete shield/connection steps. The new version is a clean 3-step drawer that handles the complete buyer flow: connect Railgun -> check balance -> enter amount -> pay -> record on-chain.

Output: Rewritten PrivatePaymentModal.jsx (~250-350 lines, down from 1632)
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-ui-rework/09-RESEARCH.md
@.planning/phases/09-ui-rework/09-01-SUMMARY.md

@frontend/src/components/railgun/PrivatePaymentModal.jsx
@frontend/src/lib/railgun-clean/index.js
@frontend/src/lib/railgun-clean/connection.js
@frontend/src/lib/railgun-clean/payments.js
@frontend/src/lib/railgun-clean/operations/transfer.js
@frontend/src/lib/railgun-clean/balances.js
@frontend/src/utils/escrowHelpers.js
@frontend/src/utils/errorHandler.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite PrivatePaymentModal as stepped drawer</name>
  <files>frontend/src/components/railgun/PrivatePaymentModal.jsx</files>
  <action>
Completely rewrite PrivatePaymentModal.jsx. The current file is 1632 lines with ~70% dead code. Write from scratch.

**IMPORTS:**
```javascript
import React, { useState, useEffect, useMemo } from 'react';
import { ethers } from 'ethers';
import toast from 'react-hot-toast';
import { Button } from '../ui/button';
import { getEscrowContract } from '../../utils/escrowHelpers';
import { decodeContractError, getExplorerUrl } from '../../utils/errorHandler';
import { NetworkName, NETWORK_CONFIG } from '@railgun-community/shared-models';
import {
  connectRailgun,
  refreshBalances,
  getAllBalances,
  privateTransfer,
  checkWalletState,
} from '../../lib/railgun-clean';
```

NOTE: The import from `../../lib/railgun-clean` resolves to the barrel export at `lib/railgun-clean/index.js` which re-exports all these functions. This barrel export exists and is verified.

Do NOT import: mock wallet managers, PrivateFundsDrawer, shield functions, backend API fetch calls, fmt18 (use ethers.formatEther instead).

**PROPS:**
```javascript
const PrivatePaymentModal = ({ product, isOpen, onClose, onSuccess, currentUser }) => {
```

**CONSTANTS:**
```javascript
const SEPOLIA_WETH_ADDRESS = NETWORK_CONFIG[NetworkName.EthereumSepolia]?.baseToken?.wrappedAddress
  || '0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14';
```

**STATE:**
```javascript
const [step, setStep] = useState('connect'); // 'connect' | 'balance' | 'pay' | 'recording' | 'complete'
const [amount, setAmount] = useState('');
const [privateBalance, setPrivateBalance] = useState(null);
const [loading, setLoading] = useState(false);
const [progress, setProgress] = useState('');
const [txResult, setTxResult] = useState(null); // { memoHash, railgunTxRef, txHash }
```

**FAST-PATH DETECTION (on mount):**
```javascript
useEffect(() => {
  if (!isOpen) return;
  const checkState = async () => {
    try {
      const state = checkWalletState();
      if (state?.isConnected && state?.walletID) {
        // Already connected -- refresh balances and skip to balance step
        await refreshBalances();
        const balances = getAllBalances();
        const wethBalance = balances?.[SEPOLIA_WETH_ADDRESS.toLowerCase()] || 0n;
        setPrivateBalance(wethBalance);
        setStep('balance');
      }
    } catch {
      // Not connected, stay on connect step
    }
  };
  checkState();
}, [isOpen]);
```

**STEP 1 - CONNECT:**
Check if Railgun wallet is connected via checkWalletState(). If not:
- Show message: "Connect your Railgun wallet to make a private payment"
- Show RailgunConnectionButton (import from same directory)
- After connection detected (poll or callback), move to balance step
- Import RailgunConnectionButton for this step:
  ```javascript
  import RailgunConnectionButton from './RailgunConnectionButton';
  ```

**STEP 2 - BALANCE:**
Show private WETH balance. If zero, suggest user visit Private Funds drawer (wrap + shield).
- Display: "Private WETH Balance: {ethers.formatEther(privateBalance)} WETH"
- If balance > 0: show green "Sufficient" or red "Insufficient" based on entered amount
- Amount input: "Payment amount (ETH)" -- buyer enters the agreed price
- "Continue to Pay" button (disabled if amount > balance or amount is 0)
- On continue: move to pay step

**STEP 3 - PAY:**
Execute the private transfer:
```javascript
const handlePay = async () => {
  setLoading(true);
  setStep('pay');
  try {
    // Get seller's Railgun address
    const sellerRailgunAddr = localStorage.getItem(`sellerRailgunAddress_${product.address}`);
    if (!sellerRailgunAddr) throw new Error("Seller's Railgun address not found");

    const amountWei = ethers.parseEther(amount);

    setProgress("Generating zero-knowledge proof...");
    const result = await privateTransfer({
      tokenAddress: SEPOLIA_WETH_ADDRESS,
      recipientAddress: sellerRailgunAddr,
      amount: amountWei,
      onProgress: (msg) => setProgress(msg),
    });

    setTxResult(result);
    setProgress("Recording payment on-chain...");

    // Record payment on-chain (FCFS buyer pattern)
    setStep('recording');
    const signer = await (new ethers.BrowserProvider(window.ethereum)).getSigner();
    const contract = getEscrowContract(product.address, signer);
    const productId = await contract.id();

    const estimatedGas = await contract.recordPrivatePayment.estimateGas(
      productId, result.memoHash, result.railgunTxRef
    );
    const gasLimit = (estimatedGas * 120n) / 100n;

    const tx = await contract.recordPrivatePayment(
      productId, result.memoHash, result.railgunTxRef, { gasLimit }
    );
    const receipt = await tx.wait();

    toast.success("Payment complete!");
    setStep('complete');
    setTxResult(prev => ({ ...prev, txHash: receipt.hash }));

    // Store in localStorage for history
    localStorage.setItem(`pending_private_payment_${product.address}`, JSON.stringify({
      memoHash: result.memoHash,
      railgunTxRef: result.railgunTxRef,
      txHash: receipt.hash,
      amount: amount,
      timestamp: Date.now(),
    }));

  } catch (err) {
    const msg = decodeContractError(err) || err.message;
    toast.error("Payment failed: " + msg);
    setStep('balance'); // return to balance step on error
  } finally {
    setLoading(false);
  }
};
```

**STEP 4 - COMPLETE:**
Show success state:
- Green checkmark
- "Payment recorded on-chain"
- Truncated memoHash with copy button
- Truncated txRef with copy button
- Explorer link for the recording transaction
- "Close" button that calls onSuccess()

**RENDER:**
Use the existing modal overlay pattern (fixed inset-0 bg-black bg-opacity-50).
The drawer content should be a right-side panel on desktop (w-96 or max-w-md) or full-width on mobile.

Show step indicator at top: Connect -> Balance -> Pay -> Done (simple breadcrumb with circles/dots).

When `!isOpen`, return null.

**DEAD CODE TO NOT INCLUDE:**
- Mock wallet manager logic (walletManager state, createWallet patterns)
- Backend API calls (fetch to RAILGUN_API_BASE)
- Shield step (moved to PrivateFundsDrawer which already exists)
- Connection polling intervals
- Multiple wallet creation patterns
- Any reference to IS_RAILGUN_API_CONFIGURED
- Old payment confirmation flow (seller confirms separately)
- fmt18 helper (use ethers.formatEther)

Target: ~250-350 lines total.
  </action>
  <verify>
    - `wc -l frontend/src/components/railgun/PrivatePaymentModal.jsx` is under 400 lines
    - `grep -c "RAILGUN_API_BASE\|IS_RAILGUN_API_CONFIGURED\|walletManager\|fmt18" frontend/src/components/railgun/PrivatePaymentModal.jsx` returns 0
    - `grep "recordPrivatePayment" frontend/src/components/railgun/PrivatePaymentModal.jsx` returns match
    - `grep "privateTransfer" frontend/src/components/railgun/PrivatePaymentModal.jsx` returns match
    - `grep "from '../../lib/railgun-clean'" frontend/src/components/railgun/PrivatePaymentModal.jsx` returns match (barrel import)
    - `grep "checkWalletState\|getAllBalances" frontend/src/components/railgun/PrivatePaymentModal.jsx` returns matches
    - Build succeeds: `cd frontend && npx react-scripts build 2>&1 | tail -5`
  </verify>
  <done>PrivatePaymentModal rewritten as 3-step drawer (~300 lines, down from 1632). Fast-path for already-connected users. Buyer enters amount, private transfer executes, recordPrivatePayment called automatically. All dead code removed. Uses barrel import from lib/railgun-clean (verified index.js exists).</done>
</task>

</tasks>

<verification>
- Modal opens with connect step for unconnected users
- Modal fast-paths to balance step for connected users
- Balance check shows sufficient/insufficient indicator
- Private transfer executes with progress feedback
- recordPrivatePayment called automatically after transfer
- Complete step shows memoHash, txRef, explorer link
- No dead code from old flow (backend API, mock wallets, shield step)
- File size under 400 lines
- Import path `../../lib/railgun-clean` resolves to barrel index.js
</verification>

<success_criteria>
- Connected + funded user: opens modal, enters amount, one-click pay, sees confirmation
- Unconnected user: prompted to connect, then proceeds to balance/pay
- Insufficient balance: clear indicator, prevented from proceeding
- Error handling: returns to balance step with toast error
- On-chain recording: recordPrivatePayment called as FCFS buyer pattern
</success_criteria>

<output>
After completion, create `.planning/phases/09-ui-rework/09-06-SUMMARY.md`
</output>
