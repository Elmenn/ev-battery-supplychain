---
phase: 08-single-vc-architecture
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/utils/vcVerifier.js
autonomous: true

must_haves:
  truths:
    - "verifyVcSchema returns true for valid v2.0 VCs and false for malformed VCs"
    - "verifyProofChain returns true when proof array has at least one valid proof entry"
    - "verifyOnChainHash returns true when keccak256(toUtf8Bytes(cid)) matches the on-chain vcHash"
    - "verifyPriceCommitment returns true when VC commitment matches contract's publicPriceCommitment"
    - "verifyVcIntegrity runs all four checks and returns a summary object"
  artifacts:
    - path: "frontend/src/utils/vcVerifier.js"
      provides: "verifyVcSchema, verifyProofChain, verifyOnChainHash, verifyPriceCommitment, verifyVcIntegrity"
      exports: ["verifyVcSchema", "verifyProofChain", "verifyOnChainHash", "verifyPriceCommitment", "verifyVcIntegrity"]
  key_links:
    - from: "frontend/src/utils/vcVerifier.js"
      to: "frontend/src/utils/vcBuilder.mjs"
      via: "hashVcPayload import"
      pattern: "import.*hashVcPayload.*from.*vcBuilder"
    - from: "frontend/src/utils/vcVerifier.js"
      to: "ethers"
      via: "keccak256 and toUtf8Bytes for on-chain hash check"
      pattern: "keccak256.*toUtf8Bytes"
---

<objective>
Create vcVerifier.js with consolidated verification logic for the new v2.0 VC format. This extracts verification concerns from the 400+ line VerifyVCInline.js UI component into reusable pure functions.

Purpose: The verifier provides programmatic VC validation that Phase 9 UI components will consume, and supports the thesis evaluation's audit trail. Currently verification logic is embedded in React component handlers -- this decouples it.

Output: New frontend/src/utils/vcVerifier.js with 5 exported functions
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-single-vc-architecture/08-RESEARCH.md
@.planning/phases/08-single-vc-architecture/08-01-SUMMARY.md
@frontend/src/utils/vcBuilder.mjs
@frontend/src/utils/commitmentUtils.js
@frontend/src/utils/verifyVc.js
@frontend/src/components/vc/VerifyVCInline.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vcVerifier.js with schema, proof chain, on-chain, and commitment verification</name>
  <files>frontend/src/utils/vcVerifier.js</files>
  <action>
Create a NEW file `frontend/src/utils/vcVerifier.js` with five exported functions. These are pure utility functions (no React, no state, no UI). They operate on VC objects and return verification results.

**Imports:**
```javascript
import { hashVcPayload } from "./vcBuilder.mjs";
import { verifyCommitmentMatch } from "./commitmentUtils";
import { keccak256, toUtf8Bytes } from "ethers";
```

**Function 1: verifyVcSchema(vc)**
Validates that a VC object has the required structure for a v2.0 VC.

Returns `{ valid: boolean, errors: string[] }`.

Checks (each failed check adds to errors array):
- `vc` is truthy and is an object
- `vc["@context"]` is an array containing `"https://www.w3.org/2018/credentials/v1"`
- `vc.type` is an array containing `"VerifiableCredential"`
- `vc.schemaVersion` is `"2.0"` (if missing, add warning but don't fail -- could be v1.0)
- `vc.issuer` exists and has `id` string starting with `"did:ethr:"`
- `vc.holder` exists and has `id` string
- `vc.issuanceDate` is a non-empty string
- `vc.credentialSubject` exists and is an object
- `vc.credentialSubject.productName` is a non-empty string
- `vc.credentialSubject.productContract` is a non-empty string
- `vc.credentialSubject.priceCommitment` exists and has `commitment` (string) and `proof` (string) -- for v2.0
- If `vc.credentialSubject.price` exists instead of priceCommitment (v1.0 pattern), accept as valid but note in errors: "v1.0 price field detected (backward compatible)"
- `vc.proof` is an array (can be empty for unsigned VCs)

`valid` is true if no errors (warnings don't count -- prefix warnings with "WARNING: ").

**Function 2: verifyProofChain(vc)**
Validates the proof array has structurally valid entries.

Returns `{ valid: boolean, proofCount: number, roles: string[], errors: string[] }`.

Checks:
- `vc.proof` is an array with length > 0
- Each proof entry has: `type` (string), `jws` (non-empty string), `verificationMethod` (string starting with "did:ethr:"), `role` (string)
- Collect unique roles from all proofs into `roles` array

NOTE: This does NOT verify cryptographic signatures (that requires the server-side verify-vc endpoint). It validates structure only.

**Function 3: verifyOnChainHash(cid, onChainVcHash)**
Verifies that `keccak256(toUtf8Bytes(cid))` matches the on-chain stored vcHash.

Parameters:
- `cid` (string): The IPFS CID of the VC
- `onChainVcHash` (string): The bytes32 hash from the contract's `vcHash` storage (hex string with 0x prefix)

Returns `{ valid: boolean, computedHash: string, onChainHash: string, error?: string }`.

Logic:
- If `!cid` or `!onChainVcHash`, return `{ valid: false, error: "CID and on-chain hash are required" }`
- Compute: `const computedHash = keccak256(toUtf8Bytes(cid))`
- Normalize both to lowercase for comparison
- Return match result with both hashes for transparency

**Function 4: verifyPriceCommitment(vc, onChainCommitment)**
Verifies that the VC's price commitment matches the on-chain `publicPriceCommitment`.

Parameters:
- `vc` (object): The VC object
- `onChainCommitment` (string): The bytes32 commitment from contract (hex string)

Returns `{ valid: boolean, vcCommitment: string, onChainCommitment: string, error?: string }`.

Logic:
- Extract commitment from VC: check `vc.credentialSubject.priceCommitment?.commitment` (v2.0) or fall back to extracting from `vc.credentialSubject.price` if it's a JSON string containing a commitment field (v1.0 backward compat)
- If no commitment found, return `{ valid: false, error: "No price commitment found in VC" }`
- Use the existing `verifyCommitmentMatch(vcCommitment, onChainCommitment)` from commitmentUtils.js
- Return result with both commitment values (normalized, without 0x prefix, lowercase)

**Function 5: verifyVcIntegrity(vc, options = {})**
Runs all applicable checks and returns a combined result.

Parameters:
- `vc` (object): The VC object
- `options` (object): Optional parameters:
  - `cid` (string): IPFS CID for on-chain hash verification
  - `onChainVcHash` (string): bytes32 from contract for hash verification
  - `onChainCommitment` (string): bytes32 from contract for commitment verification

Returns:
```javascript
{
  schema: { valid, errors },           // Always runs
  proofChain: { valid, proofCount, roles, errors },  // Always runs
  onChainHash: { valid, ... } | null,  // Only if cid + onChainVcHash provided
  priceCommitment: { valid, ... } | null,  // Only if onChainCommitment provided
  overall: boolean,  // true if all run checks passed
}
```

Logic:
- Run verifyVcSchema(vc) always
- Run verifyProofChain(vc) always
- Run verifyOnChainHash only if `options.cid` AND `options.onChainVcHash` are both provided
- Run verifyPriceCommitment only if `options.onChainCommitment` is provided
- `overall` is true only if ALL checks that ran returned valid === true. Null checks (not run) do not affect overall.

**Style notes:**
- Use JSDoc comments on each exported function
- No React imports, no DOM, no side effects
- All functions are synchronous except none need to be async (no network calls -- the on-chain reads happen at call sites in the UI layer)
- Export all five functions as named exports
  </action>
  <verify>
Run from project root:
```
node -e "
  import('./frontend/src/utils/vcVerifier.js').then(m => {
    console.log('exports:', Object.keys(m));

    // Test verifyVcSchema with a minimal v2.0 VC
    const vc = {
      '@context': ['https://www.w3.org/2018/credentials/v1'],
      type: ['VerifiableCredential', 'SupplyChainCredential'],
      schemaVersion: '2.0',
      issuer: { id: 'did:ethr:1337:0x1234', name: 'Seller' },
      holder: { id: 'did:ethr:1337:0x5678', name: 'Buyer' },
      issuanceDate: '2026-01-01T00:00:00.000Z',
      credentialSubject: {
        id: 'did:ethr:1337:0x1234',
        productName: 'Test Battery',
        productContract: '0xabcd',
        priceCommitment: { commitment: '0xaaa', proof: '0xbbb' },
      },
      proof: [{ type: 'EcdsaSecp256k1Signature2019', jws: '0xsig', verificationMethod: 'did:ethr:1337:0x1234', role: 'seller' }],
    };

    const schema = m.verifyVcSchema(vc);
    console.log('schema valid:', schema.valid, 'errors:', schema.errors);

    const proofs = m.verifyProofChain(vc);
    console.log('proofs valid:', proofs.valid, 'count:', proofs.proofCount, 'roles:', proofs.roles);

    const integrity = m.verifyVcIntegrity(vc);
    console.log('overall:', integrity.overall);
  }).catch(e => console.error('Error:', e.message));
"
```
Should show all 5 exports, schema valid: true, proofs valid: true with 1 proof, overall: true.
  </verify>
  <done>
  - vcVerifier.js exists at frontend/src/utils/vcVerifier.js
  - Exports 5 functions: verifyVcSchema, verifyProofChain, verifyOnChainHash, verifyPriceCommitment, verifyVcIntegrity
  - verifyVcSchema validates v2.0 VC structure with descriptive errors
  - verifyProofChain validates proof array structure (not cryptographic verification)
  - verifyOnChainHash compares keccak256(toUtf8Bytes(cid)) against on-chain vcHash
  - verifyPriceCommitment uses commitmentUtils.verifyCommitmentMatch for commitment comparison
  - verifyVcIntegrity orchestrates all checks with optional on-chain parameters
  - No React dependencies, pure utility functions
  </done>
</task>

</tasks>

<verification>
- `frontend/src/utils/vcVerifier.js` exists and exports all 5 functions
- verifyVcSchema catches missing @context, missing issuer, missing priceCommitment
- verifyVcSchema passes for well-formed v2.0 VCs
- verifyProofChain validates proof entry structure (type, jws, verificationMethod, role)
- verifyOnChainHash uses keccak256(toUtf8Bytes(cid)) matching the contract's hash algorithm
- verifyPriceCommitment handles both v2.0 (priceCommitment object) and v1.0 (price string) formats
- verifyVcIntegrity returns overall: true only when all run checks pass
- No UI components modified
</verification>

<success_criteria>
Consolidated VC verification utility exists with schema validation, proof chain checking, on-chain hash verification, and price commitment matching. Ready for Phase 9 UI integration.
</success_criteria>

<output>
After completion, create `.planning/phases/08-single-vc-architecture/08-03-SUMMARY.md`
</output>
