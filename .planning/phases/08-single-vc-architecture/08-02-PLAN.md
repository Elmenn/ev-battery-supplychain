---
phase: 08-single-vc-architecture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/utils/ipfs.js
  - frontend/src/utils/signVcWithMetamask.js
autonomous: true

must_haves:
  truths:
    - "fetchJson(cid) returns parsed JSON from IPFS given a valid CID"
    - "fetchJson(cid) returns cached result on second call without hitting network"
    - "fetchJson(cid) retries up to 3 times with exponential backoff on failure"
    - "EIP-712 signing strips payment, delivery, and previousVersion before signing"
    - "EIP-712 signing includes listing section fields in the signed payload"
    - "Existing signVcWithMetamask and signVcAsSeller exports still work for v1.0 VCs"
  artifacts:
    - path: "frontend/src/utils/ipfs.js"
      provides: "uploadJson, fetchJson"
      exports: ["uploadJson", "fetchJson"]
    - path: "frontend/src/utils/signVcWithMetamask.js"
      provides: "signVcWithMetamask, signVcAsSeller with updated EIP-712 types"
      exports: ["signVcWithMetamask", "signVcAsSeller"]
  key_links:
    - from: "frontend/src/utils/ipfs.js"
      to: "https://ipfs.io/ipfs"
      via: "fetch with retry"
      pattern: "fetch.*ipfs.*gateway"
    - from: "frontend/src/utils/ipfs.js"
      to: "localStorage"
      via: "cache get/set"
      pattern: "localStorage\\.(get|set)Item"
    - from: "frontend/src/utils/signVcWithMetamask.js"
      to: "ethers"
      via: "TypedDataEncoder and signTypedData"
      pattern: "signTypedData"
---

<objective>
Add IPFS fetch utility with caching and retry logic, and update EIP-712 signing types to handle the new schemaVersion 2.0 VC structure.

Purpose: These two utilities are consumed by the VC verifier (Plan 08-03) and by UI components (Phase 9). They are independent of the vcBuilder rewrite (Plan 08-01) since ipfs.js and signVcWithMetamask.js do not import from vcBuilder.mjs.

Output: Updated ipfs.js with fetchJson export, updated signVcWithMetamask.js with v2.0-compatible EIP-712 types
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-single-vc-architecture/08-RESEARCH.md
@frontend/src/utils/ipfs.js
@frontend/src/utils/signVcWithMetamask.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fetchJson to ipfs.js with caching and retry</name>
  <files>frontend/src/utils/ipfs.js</files>
  <action>
Add a `fetchJson(cid)` export to the existing `ipfs.js` file. Keep the existing `uploadJson` function and Pinata JWT setup completely unchanged.

Implementation details:

1. **Gateway constant** at top of file:
   ```
   const IPFS_GATEWAY = "https://ipfs.io/ipfs";
   ```

2. **Retry helper** (internal, not exported):
   ```
   async function fetchWithRetry(url, maxRetries = 3)
   ```
   - Attempts fetch up to `maxRetries` times
   - Exponential backoff: 1s, 2s, 4s (delay = 1000 * 2^attempt)
   - On each failure, log a warning: `console.warn(\`IPFS fetch attempt ${attempt+1}/${maxRetries} failed: ${err.message}\`)`
   - After all retries exhausted, throw the last error
   - Only retry on network errors and 5xx responses. Do NOT retry 4xx (client errors).

3. **fetchJson(cid)** export:
   - Validate: if `!cid` throw `new Error("CID is required")`
   - Strip any "ipfs://" prefix: `cid = cid.replace(/^ipfs:\/\//, "")`
   - **Cache check**: `const cacheKey = \`vc_cache_${cid}\``; check `localStorage.getItem(cacheKey)`. If found, try `JSON.parse`. If parse succeeds, return cached value. If parse fails (corrupted), remove the key and continue to fetch.
   - **Fetch**: call `fetchWithRetry(\`${IPFS_GATEWAY}/${cid}\`)`. Check `response.ok`. If not ok, throw `new Error(\`IPFS fetch failed (${response.status}): ${response.statusText}\`)`.
   - **Parse**: `const json = await response.json()`
   - **Cache write**: wrap in try/catch to handle quota exceeded silently: `try { localStorage.setItem(cacheKey, JSON.stringify(json)); } catch { /* storage quota exceeded, skip caching */ }`
   - **Return**: `json`

Do NOT modify the existing `uploadJson` function or the JWT setup at the top of the file. Only ADD the new constant, helper, and export.
  </action>
  <verify>
Run from project root:
```
node -e "
  // Mock localStorage and fetch for Node testing
  const store = {};
  global.localStorage = {
    getItem: k => store[k] || null,
    setItem: (k,v) => store[k] = v,
    removeItem: k => delete store[k]
  };
  // Just verify the module parses and exports fetchJson
  import('./frontend/src/utils/ipfs.js').then(m => {
    console.log('exports:', Object.keys(m));
    console.log('has fetchJson:', typeof m.fetchJson === 'function');
    console.log('has uploadJson:', typeof m.uploadJson === 'function');
  }).catch(e => console.error('Import error:', e.message));
"
```
Should show both `fetchJson` and `uploadJson` as exports. The actual IPFS fetch cannot be tested without network, but the module should parse without errors.
  </verify>
  <done>
  - fetchJson is exported from ipfs.js
  - uploadJson is unchanged
  - fetchJson checks localStorage cache before network request
  - fetchJson retries up to 3 times with exponential backoff
  - fetchJson strips "ipfs://" prefix from CID
  - fetchJson caches successful fetches in localStorage with key `vc_cache_{cid}`
  </done>
</task>

<task type="auto">
  <name>Task 2: Update EIP-712 types for v2.0 VC schema</name>
  <files>frontend/src/utils/signVcWithMetamask.js</files>
  <action>
Update `preparePayloadForSigning()` and the EIP-712 `types` object in `signPayload()` to handle the new v2.0 VC schema while maintaining backward compatibility with v1.0 VCs.

**Key principle from research:** Sign only IMMUTABLE parts. Strip mutable sections (payment, delivery, previousVersion) in `preparePayloadForSigning()`. This way the seller's listing signature remains valid after buyer appends payment proof.

**Changes to `preparePayloadForSigning(vc)`:**

Add these deletions AFTER the existing deletions (after line 29, before the price serialization):
```javascript
// Strip mutable sections for v2.0 VCs (these change over VC lifecycle)
if (clone.credentialSubject?.payment !== undefined) {
  delete clone.credentialSubject.payment;
}
if (clone.credentialSubject?.delivery !== undefined) {
  delete clone.credentialSubject.delivery;
}
if (clone.previousVersion !== undefined) {
  delete clone.previousVersion;
}
```

Also strip the `listing` sub-object's mutable fields but KEEP the listing data for signing. Actually, the listing section is immutable (set once at creation and never changed), so it should be SIGNED. However, EIP-712 requires explicit type definitions for nested objects. To avoid type explosion, flatten the listing fields into the signed payload:

```javascript
// For v2.0 VCs, flatten listing into credentialSubject for signing
if (clone.credentialSubject?.listing) {
  // Move listing fields up to credentialSubject level for EIP-712 compatibility
  clone.credentialSubject.certificateCredential = clone.credentialSubject.listing.certificateCredential || { name: "", cid: "" };
  clone.credentialSubject.componentCredentials = clone.credentialSubject.listing.componentCredentials || [];
  delete clone.credentialSubject.listing;
}
```

Wait -- looking at the existing code more carefully, the v1.0 VCs already have `certificateCredential` and `componentCredentials` at the `credentialSubject` level (lines 45-58 show defaults being set). The v2.0 schema nests them under `listing`. So the flattening above makes the v2.0 VCs compatible with the existing EIP-712 types. This is the right approach.

Also strip `priceCommitment` object and serialize it as a string (same treatment as existing `price` field), since EIP-712 cannot handle dynamic nested objects with varying fields:

Actually no -- looking at the existing types, `price` is already a `string` type in the EIP-712 definition (line 129). The v2.0 schema uses `priceCommitment` (an object) instead of `price` (a string). We need to serialize `priceCommitment` to a string for EIP-712 signing:

```javascript
// For v2.0 VCs, serialize priceCommitment object to string for EIP-712
if (clone.credentialSubject?.priceCommitment && typeof clone.credentialSubject.priceCommitment === 'object') {
  try {
    clone.credentialSubject.price = JSON.stringify(clone.credentialSubject.priceCommitment);
  } catch {
    clone.credentialSubject.price = String(clone.credentialSubject.priceCommitment);
  }
  delete clone.credentialSubject.priceCommitment;
}
```

This should go BEFORE the existing price serialization block (lines 31-37), so the existing block handles any edge cases.

**Summary of preparePayloadForSigning changes (in order):**
1. Existing: delete proofs, vcHash, transactionId, txHashCommitment, purchaseTxHashCommitment (keep all existing deletions)
2. NEW: delete payment, delivery, previousVersion (mutable sections)
3. NEW: if priceCommitment is an object, serialize to price string and delete priceCommitment
4. Existing: price string serialization (handles edge cases)
5. NEW: if listing exists, flatten certificateCredential and componentCredentials up, delete listing
6. Existing: ensure certificateCredential default, componentCredentials default, previousCredential default
7. Existing: lowercase IDs, ensure schemaVersion

**DO NOT change the EIP-712 `types` object in `signPayload()`.** The existing types already handle all fields after the flattening in `preparePayloadForSigning`. The `price` type is `string` which handles the serialized priceCommitment. The `Certificate` type handles certificateCredential. The `previousCredential` field is kept (set to empty string for v2.0 VCs that use `previousVersion` instead).

**DO NOT change `signPayload()`, `signVcWithMetamask()`, or `signVcAsSeller()` function signatures or logic.** Only `preparePayloadForSigning` needs updating.

**Backward compatibility:** v1.0 VCs do not have `payment`, `delivery`, `previousVersion`, `listing`, or `priceCommitment` object fields. The new deletions use conditional checks (`if (clone.x !== undefined)`) so they are no-ops for v1.0 VCs.
  </action>
  <verify>
Run from project root:
```
node -e "
  import('./frontend/src/utils/signVcWithMetamask.js').then(m => {
    console.log('exports:', Object.keys(m));
    console.log('has signVcWithMetamask:', typeof m.signVcWithMetamask === 'function');
    console.log('has signVcAsSeller:', typeof m.signVcAsSeller === 'function');
  }).catch(e => console.error('Import error:', e.message));
"
```
Module should parse without errors and export both signing functions. Full signing test requires MetaMask (Phase 9 integration), but the module structure should be valid.
  </verify>
  <done>
  - preparePayloadForSigning strips payment, delivery, previousVersion from v2.0 VCs
  - preparePayloadForSigning serializes priceCommitment object to price string for EIP-712
  - preparePayloadForSigning flattens listing.certificateCredential and listing.componentCredentials to credentialSubject level
  - All existing v1.0 VC signing behavior preserved (conditional checks are no-ops for v1.0)
  - EIP-712 types object unchanged (flattening makes v2.0 compatible with existing types)
  - signVcWithMetamask and signVcAsSeller exports unchanged
  </done>
</task>

</tasks>

<verification>
- `frontend/src/utils/ipfs.js` exports both `uploadJson` and `fetchJson`
- `fetchJson` has localStorage caching with `vc_cache_` prefix
- `fetchJson` has retry logic (3 attempts, exponential backoff)
- `frontend/src/utils/signVcWithMetamask.js` exports `signVcWithMetamask` and `signVcAsSeller`
- `preparePayloadForSigning` strips mutable sections (payment, delivery, previousVersion)
- `preparePayloadForSigning` handles both v1.0 and v2.0 VC formats
- No changes to uploadJson, signPayload, or function signatures
</verification>

<success_criteria>
IPFS fetchJson utility with caching + retry is available for components and verifier. EIP-712 signing handles both old v1.0 and new v2.0 VC schemas without breaking existing functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/08-single-vc-architecture/08-02-SUMMARY.md`
</output>
