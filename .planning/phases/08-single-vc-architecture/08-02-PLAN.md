---
phase: 08-single-vc-architecture
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/utils/ipfs.js
  - frontend/src/utils/signVcWithMetamask.js
autonomous: true

must_haves:
  truths:
    - "fetchJson(cid) returns parsed JSON from IPFS given a valid CID"
    - "fetchJson(cid) returns cached result on second call without hitting network"
    - "fetchJson(cid) retries up to 3 times with exponential backoff on failure"
    - "uploadJson(obj) retries up to 3 times with exponential backoff on failure"
    - "EIP-712 signing strips payment, delivery, and previousVersion before signing"
    - "EIP-712 signing includes listing section fields in the signed payload"
    - "Existing signVcWithMetamask and signVcAsSeller exports still work for v1.0 VCs"
  artifacts:
    - path: "frontend/src/utils/ipfs.js"
      provides: "uploadJson (with retry), fetchJson (with retry and caching)"
      exports: ["uploadJson", "fetchJson"]
    - path: "frontend/src/utils/signVcWithMetamask.js"
      provides: "signVcWithMetamask, signVcAsSeller with updated EIP-712 types"
      exports: ["signVcWithMetamask", "signVcAsSeller"]
  key_links:
    - from: "frontend/src/utils/ipfs.js"
      to: "https://ipfs.io/ipfs"
      via: "fetch with retry"
      pattern: "fetch.*ipfs.*gateway"
    - from: "frontend/src/utils/ipfs.js"
      to: "localStorage"
      via: "cache get/set"
      pattern: "localStorage\\.(get|set)Item"
    - from: "frontend/src/utils/signVcWithMetamask.js"
      to: "ethers"
      via: "TypedDataEncoder and signTypedData"
      pattern: "signTypedData"
---

<objective>
Add IPFS fetch utility with caching and retry logic, add retry logic to existing uploadJson, and update EIP-712 signing types to handle the new schemaVersion 2.0 VC structure.

Purpose: These two utilities are consumed by the VC verifier (Plan 08-03) and by UI components (Phase 9). They are independent of the vcBuilder rewrite (Plan 08-01) since ipfs.js and signVcWithMetamask.js do not import from vcBuilder.mjs.

Output: Updated ipfs.js with fetchJson export and uploadJson retry, updated signVcWithMetamask.js with v2.0-compatible EIP-712 types
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-single-vc-architecture/08-RESEARCH.md
@frontend/src/utils/ipfs.js
@frontend/src/utils/signVcWithMetamask.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fetchJson and uploadJson retry to ipfs.js</name>
  <files>frontend/src/utils/ipfs.js</files>
  <action>
Add a `fetchJson(cid)` export and retry logic for both `fetchJson` and `uploadJson` to the existing `ipfs.js` file. Keep the existing Pinata JWT setup unchanged.

Implementation details:

1. **Gateway constant** at top of file (after JWT check):
   ```
   const IPFS_GATEWAY = "https://ipfs.io/ipfs";
   ```

2. **Retry helper** (internal, not exported):
   ```
   async function withRetry(fn, maxRetries = 3)
   ```
   - Takes an async function `fn` and calls it
   - Attempts up to `maxRetries` times
   - Exponential backoff: 1s, 2s, 4s (delay = 1000 * 2^attempt)
   - On each failure, log a warning: `console.warn(\`Retry attempt ${attempt+1}/${maxRetries} failed: ${err.message}\`)`
   - After all retries exhausted, throw the last error
   - Only retry on network errors and 5xx responses. Do NOT retry 4xx (client errors). To distinguish: if the error has a `status` property in the 400-499 range, throw immediately without retrying.

3. **Wrap existing uploadJson body in retry logic:**
   - Keep the function signature `export async function uploadJson(obj)` unchanged
   - Move the existing fetch+response logic into an inner function passed to `withRetry`
   - The formatting (JSON.stringify with 2-space indent), FormData construction, and Pinata API call all stay the same
   - The error handling for non-ok responses stays the same, but add a `status` property to thrown errors for 4xx detection: `const err = new Error(\`Pinata upload failed: ${errMsg}\`); err.status = res.status; throw err;`

4. **fetchJson(cid)** export:
   - Validate: if `!cid` throw `new Error("CID is required")`
   - Strip any "ipfs://" prefix: `cid = cid.replace(/^ipfs:\/\//, "")`
   - **Cache check**: `const cacheKey = \`vc_cache_${cid}\``; check `localStorage.getItem(cacheKey)`. If found, try `JSON.parse`. If parse succeeds, return cached value. If parse fails (corrupted), remove the key and continue to fetch.
   - **Fetch with retry**: call `withRetry(async () => { ... })` where the inner function does:
     - `const response = await fetch(\`${IPFS_GATEWAY}/${cid}\`)`
     - If `!response.ok`: create error with status property, throw it
     - Return `await response.json()`
   - **Cache write**: wrap in try/catch to handle quota exceeded silently: `try { localStorage.setItem(cacheKey, JSON.stringify(json)); } catch { /* storage quota exceeded, skip caching */ }`
   - **Return**: `json`
  </action>
  <verify>
Run from project root:
```
node -e "
  // Mock localStorage and fetch for Node testing
  const store = {};
  global.localStorage = {
    getItem: k => store[k] || null,
    setItem: (k,v) => store[k] = v,
    removeItem: k => delete store[k]
  };
  // Just verify the module parses and exports fetchJson and uploadJson
  import('./frontend/src/utils/ipfs.js').then(m => {
    console.log('exports:', Object.keys(m));
    console.log('has fetchJson:', typeof m.fetchJson === 'function');
    console.log('has uploadJson:', typeof m.uploadJson === 'function');
  }).catch(e => console.error('Import error:', e.message));
"
```
Should show both `fetchJson` and `uploadJson` as exports. The actual IPFS fetch/upload cannot be tested without network, but the module should parse without errors.
  </verify>
  <done>
  - fetchJson is exported from ipfs.js
  - uploadJson is preserved and now uses retry logic via withRetry helper
  - fetchJson checks localStorage cache before network request
  - Both fetchJson and uploadJson retry up to 3 times with exponential backoff
  - 4xx errors are NOT retried (only network errors and 5xx)
  - fetchJson strips "ipfs://" prefix from CID
  - fetchJson caches successful fetches in localStorage with key `vc_cache_{cid}`
  </done>
</task>

<task type="auto">
  <name>Task 2: Update EIP-712 types for v2.0 VC schema</name>
  <files>frontend/src/utils/signVcWithMetamask.js</files>
  <action>
Update `preparePayloadForSigning()` in `signVcWithMetamask.js` to handle the new v2.0 VC schema while maintaining backward compatibility with v1.0 VCs.

**Key principle from research:** Sign only IMMUTABLE parts. Strip mutable sections (payment, delivery, previousVersion) in `preparePayloadForSigning()`. This way the seller's listing signature remains valid after buyer appends payment proof.

**Changes to `preparePayloadForSigning(vc)` -- add these in order AFTER the existing deletions (after line 29, before the price serialization):**

**Step A: Strip mutable sections for v2.0 VCs:**
```javascript
if (clone.credentialSubject?.payment !== undefined) {
  delete clone.credentialSubject.payment;
}
if (clone.credentialSubject?.delivery !== undefined) {
  delete clone.credentialSubject.delivery;
}
if (clone.previousVersion !== undefined) {
  delete clone.previousVersion;
}
```

**Step B: Serialize priceCommitment object to price string for EIP-712 (BEFORE the existing price serialization block):**
```javascript
if (clone.credentialSubject?.priceCommitment && typeof clone.credentialSubject.priceCommitment === 'object') {
  try {
    clone.credentialSubject.price = JSON.stringify(clone.credentialSubject.priceCommitment);
  } catch {
    clone.credentialSubject.price = String(clone.credentialSubject.priceCommitment);
  }
  delete clone.credentialSubject.priceCommitment;
}
```

**Step C: Flatten listing sub-object for EIP-712 compatibility:**
The v1.0 VCs have `certificateCredential` and `componentCredentials` directly on `credentialSubject`. The v2.0 schema nests them under `listing`. Flattening makes v2.0 VCs compatible with the existing EIP-712 types.
```javascript
if (clone.credentialSubject?.listing) {
  clone.credentialSubject.certificateCredential = clone.credentialSubject.listing.certificateCredential || { name: "", cid: "" };
  clone.credentialSubject.componentCredentials = clone.credentialSubject.listing.componentCredentials || [];
  delete clone.credentialSubject.listing;
}
```

**Summary of preparePayloadForSigning changes (in order):**
1. Existing: delete proofs, vcHash, transactionId, txHashCommitment, purchaseTxHashCommitment (keep all existing deletions)
2. NEW (Step A): delete payment, delivery, previousVersion (mutable sections)
3. NEW (Step B): if priceCommitment is an object, serialize to price string and delete priceCommitment
4. Existing: price string serialization (handles edge cases)
5. NEW (Step C): if listing exists, flatten certificateCredential and componentCredentials up, delete listing
6. Existing: ensure certificateCredential default, componentCredentials default, previousCredential default
7. Existing: lowercase IDs, ensure schemaVersion

**DO NOT change the EIP-712 `types` object in `signPayload()`.** The existing types already handle all fields after the flattening in `preparePayloadForSigning`. The `price` type is `string` which handles the serialized priceCommitment. The `Certificate` type handles certificateCredential.

**DO NOT change `signPayload()`, `signVcWithMetamask()`, or `signVcAsSeller()` function signatures or logic.** Only `preparePayloadForSigning` needs updating.

**Backward compatibility:** v1.0 VCs do not have `payment`, `delivery`, `previousVersion`, `listing`, or `priceCommitment` object fields. The new deletions use conditional checks (`if (clone.x !== undefined)`) so they are no-ops for v1.0 VCs.
  </action>
  <verify>
Run from project root:
```
node -e "
  import('./frontend/src/utils/signVcWithMetamask.js').then(m => {
    console.log('exports:', Object.keys(m));
    console.log('has signVcWithMetamask:', typeof m.signVcWithMetamask === 'function');
    console.log('has signVcAsSeller:', typeof m.signVcAsSeller === 'function');

    // Test that preparePayloadForSigning strips v2.0 mutable fields
    if (typeof m.preparePayloadForSigning === 'function') {
      const v2vc = {
        '@context': ['https://www.w3.org/2018/credentials/v1'],
        type: ['VerifiableCredential'],
        schemaVersion: '2.0',
        issuer: { id: 'did:ethr:1337:0x1234', name: 'Seller' },
        holder: { id: 'did:ethr:1337:0x5678' },
        issuanceDate: '2026-01-01T00:00:00Z',
        credentialSubject: {
          id: 'did:ethr:1337:0x1234',
          productName: 'Battery',
          productContract: '0xabcd',
          priceCommitment: { commitment: '0xaaa', proof: '0xbbb', protocol: 'bulletproofs-pedersen' },
          listing: { certificateCredential: { name: 'cert', cid: 'QmX' }, componentCredentials: [] },
          payment: { timestamp: '2026-01-02T00:00:00Z', buyerAddress: '0x5678' },
          delivery: { timestamp: '2026-01-03T00:00:00Z' },
        },
        previousVersion: 'QmOldCid',
        proof: [{ jws: '0xsig' }],
      };
      const prepared = m.preparePayloadForSigning(v2vc);
      console.log('payment stripped:', prepared.credentialSubject.payment === undefined);
      console.log('delivery stripped:', prepared.credentialSubject.delivery === undefined);
      console.log('previousVersion stripped:', prepared.previousVersion === undefined);
      console.log('listing flattened:', prepared.credentialSubject.listing === undefined);
      console.log('has certificateCredential:', prepared.credentialSubject.certificateCredential !== undefined);
      console.log('price is string:', typeof prepared.credentialSubject.price === 'string');

      // Test v1.0 backward compat
      const v1vc = {
        '@context': ['https://www.w3.org/2018/credentials/v1'],
        type: ['VerifiableCredential'],
        schemaVersion: '1.0',
        issuer: { id: 'did:ethr:1337:0x1234', name: 'Seller' },
        holder: { id: 'did:ethr:1337:0x5678' },
        issuanceDate: '2026-01-01T00:00:00Z',
        credentialSubject: {
          id: 'did:ethr:1337:0x1234',
          productName: 'Battery',
          productContract: '0xabcd',
          price: '100',
          certificateCredential: { name: 'cert', cid: 'QmX' },
          componentCredentials: [],
        },
        proof: [],
      };
      const v1prepared = m.preparePayloadForSigning(v1vc);
      console.log('v1.0 price preserved:', v1prepared.credentialSubject.price === '100');
      console.log('v1.0 cert preserved:', v1prepared.credentialSubject.certificateCredential.name === 'cert');
    } else {
      console.log('preparePayloadForSigning not exported -- verify manually that internal function works');
    }
  }).catch(e => console.error('Import error:', e.message));
"
```
Module should parse without errors, export both signing functions, and (if preparePayloadForSigning is exported) confirm that v2.0 mutable fields are stripped and v1.0 VCs pass through unchanged.
  </verify>
  <done>
  - preparePayloadForSigning strips payment, delivery, previousVersion from v2.0 VCs
  - preparePayloadForSigning serializes priceCommitment object to price string for EIP-712
  - preparePayloadForSigning flattens listing.certificateCredential and listing.componentCredentials to credentialSubject level
  - All existing v1.0 VC signing behavior preserved (conditional checks are no-ops for v1.0)
  - EIP-712 types object unchanged (flattening makes v2.0 compatible with existing types)
  - signVcWithMetamask and signVcAsSeller exports unchanged
  - uploadJson now retries with exponential backoff (matching fetchJson)
  </done>
</task>

</tasks>

<verification>
- `frontend/src/utils/ipfs.js` exports both `uploadJson` and `fetchJson`
- `uploadJson` uses retry logic (3 attempts, exponential backoff, no retry on 4xx)
- `fetchJson` has localStorage caching with `vc_cache_` prefix
- `fetchJson` has retry logic (3 attempts, exponential backoff)
- `frontend/src/utils/signVcWithMetamask.js` exports `signVcWithMetamask` and `signVcAsSeller`
- `preparePayloadForSigning` strips mutable sections (payment, delivery, previousVersion)
- `preparePayloadForSigning` handles both v1.0 and v2.0 VC formats
- v2.0 VC with payment/delivery/previousVersion produces a prepared payload without those fields
- v1.0 VC with price string produces the same prepared payload as before
- No changes to signPayload, signVcWithMetamask, or signVcAsSeller function signatures
</verification>

<success_criteria>
IPFS fetchJson utility with caching + retry is available for components and verifier. uploadJson has matching retry logic. EIP-712 signing handles both old v1.0 and new v2.0 VC schemas without breaking existing functionality.
</success_criteria>

<output>
After completion, create `.planning/phases/08-single-vc-architecture/08-02-SUMMARY.md`
</output>
