---
phase: 06-on-chain-recording
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/utils/errorHandler.js
  - frontend/src/components/railgun/PrivatePaymentModal.jsx
autonomous: true

must_haves:
  truths:
    - "After Railgun transfer confirms, recordPrivatePayment is called immediately"
    - "User sees specific error messages when recording fails"
    - "Success toast shows Etherscan link after recording"
    - "Pending state persists across page refresh"
  artifacts:
    - path: "frontend/src/utils/errorHandler.js"
      provides: "decodeContractError function for ProductEscrow errors"
      exports: ["decodeContractError"]
    - path: "frontend/src/components/railgun/PrivatePaymentModal.jsx"
      provides: "recordPrivatePayment call after privateTransfer"
      contains: "contract.recordPrivatePayment"
  key_links:
    - from: "PrivatePaymentModal.jsx"
      to: "ProductEscrow contract"
      via: "ethers Contract.recordPrivatePayment()"
      pattern: "contract\\.recordPrivatePayment"
    - from: "PrivatePaymentModal.jsx"
      to: "errorHandler.js"
      via: "import decodeContractError"
      pattern: "decodeContractError"
---

<objective>
Add on-chain recording of private payment reference immediately after Railgun transfer succeeds.

Purpose: Link the Railgun privacy transaction to the supply chain product state so the product transitions to "Purchased" phase.

Output: Working recordPrivatePayment flow in PrivatePaymentModal that calls the ProductEscrow contract after privateTransfer completes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-on-chain-recording/06-RESEARCH.md

Key existing code:
- `frontend/src/components/railgun/PrivatePaymentModal.jsx` - Current payment flow (lines 949-1007)
- `frontend/src/utils/errorHandler.js` - Has getExplorerUrl, needs decodeContractError
- `frontend/src/abis/ProductEscrow_Initializer.json` - ABI for recordPrivatePayment
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add decodeContractError to errorHandler.js</name>
  <files>frontend/src/utils/errorHandler.js</files>
  <action>
Add a new exported function `decodeContractError(error)` that maps ProductEscrow contract errors to user-friendly messages.

Error map (from contract):
- WrongProductId -> "Wrong product ID - check contract address"
- ZeroMemoHash -> "Invalid memo hash - payment may have failed"
- ZeroTxRef -> "Invalid transaction reference"
- AlreadyPurchased -> "Product already purchased"
- PrivateDisabled -> "Private payments are disabled for this product"
- AlreadyPaid -> "Payment already recorded"
- MemoAlreadyUsed -> "This payment was already used"
- PaymentAlreadyRecorded -> "Payment already confirmed on-chain"
- NotParticipant -> "Only buyer or seller can record payment"

The function should:
1. Convert error to string
2. Check for each error name in the string
3. Return the user-friendly message if found
4. Fall back to extractErrorMessage(error) if no match

Add at the end of the file, before the final empty line.
  </action>
  <verify>
Run: `grep -n "decodeContractError" frontend/src/utils/errorHandler.js`
Expected: Function definition found
  </verify>
  <done>
decodeContractError function exported from errorHandler.js, handles all 9 ProductEscrow error types
  </done>
</task>

<task type="auto">
  <name>Task 2: Add recordPrivatePayment flow to PrivatePaymentModal</name>
  <files>frontend/src/components/railgun/PrivatePaymentModal.jsx</files>
  <action>
Modify the `handlePrivatePayment` function (around line 951-1007) to call recordPrivatePayment after privateTransfer succeeds.

**Add imports at top of file:**
```javascript
import { getExplorerUrl, decodeContractError } from '../../utils/errorHandler';
import ESCROW_ABI from '../../abis/ProductEscrow_Initializer.json';
```

**After line 983 (localStorage.setItem for pendingKey), add recording flow:**

1. Update pending state to 'recording':
```javascript
pendingPaymentData.status = 'recording';
localStorage.setItem(pendingKey, JSON.stringify(pendingPaymentData));
```

2. Show recording progress:
```javascript
setTransferProgress({ step: 'recording', message: 'Recording payment on-chain...', progress: 80 });
```

3. Get signer and create contract:
```javascript
const provider = new ethers.BrowserProvider(window.ethereum);
const signer = await provider.getSigner();
const productAddress = product.address || product.contractAddress;
const contract = new ethers.Contract(productAddress, ESCROW_ABI, signer);
```

4. Get product ID from contract:
```javascript
const contractProductId = await contract.id();
```

5. Preflight check with staticCall (catches errors early):
```javascript
try {
  await contract.recordPrivatePayment.staticCall(
    contractProductId,
    result.memoHash,
    result.railgunTxRef
  );
} catch (preflightError) {
  const userMessage = decodeContractError(preflightError);
  throw new Error(`Recording will fail: ${userMessage}`);
}
```

6. Estimate gas with 20% headroom:
```javascript
const estimatedGas = await contract.recordPrivatePayment.estimateGas(
  contractProductId,
  result.memoHash,
  result.railgunTxRef
);
const gasLimit = (estimatedGas * 120n) / 100n;
```

7. Send transaction:
```javascript
const recordTx = await contract.recordPrivatePayment(
  contractProductId,
  result.memoHash,
  result.railgunTxRef,
  { gasLimit }
);

setTransferProgress({ step: 'confirming', message: 'Waiting for on-chain confirmation...', progress: 90 });
const recordReceipt = await recordTx.wait();
```

8. Update localStorage with confirmed status:
```javascript
pendingPaymentData.status = 'confirmed';
pendingPaymentData.recordTxHash = recordReceipt.hash;
localStorage.setItem(pendingKey, JSON.stringify(pendingPaymentData));
```

9. Show success toast with Etherscan link (replace existing toast.success on line 998):
```javascript
const chainId = (await provider.getNetwork()).chainId;
const explorerUrl = getExplorerUrl(recordReceipt.hash, Number(chainId));

toast.success(
  <div>
    <p>Private payment recorded on-chain!</p>
    {explorerUrl && (
      <a
        href={explorerUrl}
        target="_blank"
        rel="noreferrer"
        className="text-blue-500 underline text-sm"
      >
        View on Etherscan
      </a>
    )}
  </div>,
  { duration: 5000 }
);
```

**Remove the old toast.success line (998) that just shows truncated tx hash.**

**Error handling:** The existing catch block (lines 1001-1004) will catch recording errors. Update it to use decodeContractError:
```javascript
} catch (error) {
  console.error("Private payment failed:", error);
  const userMessage = decodeContractError(error);
  toast.error("Private payment failed: " + userMessage);
}
```
  </action>
  <verify>
1. Search for recordPrivatePayment in the file:
   `grep -n "recordPrivatePayment" frontend/src/components/railgun/PrivatePaymentModal.jsx`
   Expected: Multiple lines showing contract call

2. Search for decodeContractError import:
   `grep -n "decodeContractError" frontend/src/components/railgun/PrivatePaymentModal.jsx`
   Expected: Import statement found

3. Search for Etherscan link in toast:
   `grep -n "View on Etherscan" frontend/src/components/railgun/PrivatePaymentModal.jsx`
   Expected: Toast JSX found
  </verify>
  <done>
PrivatePaymentModal calls recordPrivatePayment immediately after privateTransfer succeeds, shows specific errors via decodeContractError, displays Etherscan link in success toast
  </done>
</task>

</tasks>

<verification>
After both tasks:

1. **Code check:** Verify imports and function calls are wired:
   ```bash
   grep -n "decodeContractError" frontend/src/utils/errorHandler.js frontend/src/components/railgun/PrivatePaymentModal.jsx
   grep -n "recordPrivatePayment" frontend/src/components/railgun/PrivatePaymentModal.jsx
   ```

2. **Build check:** Run `npm run build` in frontend directory - no TypeScript/ESLint errors

3. **Integration readiness:** The flow is ready for manual testing in Phase 6 Plan 2 (UI updates)
</verification>

<success_criteria>
- [ ] decodeContractError function exists in errorHandler.js with all 9 error types
- [ ] PrivatePaymentModal imports decodeContractError and ESCROW_ABI
- [ ] recordPrivatePayment called after privateTransfer success
- [ ] localStorage updated with 'recording' then 'confirmed' status
- [ ] Success toast shows Etherscan link
- [ ] Error messages are user-friendly (not raw contract errors)
- [ ] Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-on-chain-recording/06-01-SUMMARY.md`
</output>
